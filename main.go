// main.go
package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/go-chi/chi/v5/middleware"

	// Import for Swagger UI
	httpSwagger "github.com/swaggo/http-swagger/v2"

	_ "github.com/jeana-hines/personal-reading-list-api/docs" // This will be generated by `swag init`
	"github.com/jeana-hines/personal-reading-list-api/handlers"
	"github.com/jeana-hines/personal-reading-list-api/models"
)

// @title           Personal Reading List API
// @version         1.0
// @description     API for managing personalized reading lists, with summarization and tagging.
// @host            localhost:8080
// @BasePath        /api/v1
func main() {
	// Initialize Database
	models.InitDB("./reading_list.db") // This will create/open 'reading_list.db' in project root
	defer models.CloseDB()

	// Initialize Chi Router
	// Chi is a lightweight router for Go HTTP services
	r := chi.NewRouter()
	r.Use(middleware.Logger) // Logs incoming requests

	// API ROUTES

	// This is a simple health check endpoint to verify the API is running
	r.Get("/api/v1", healthCheckHandler)

	// User Authentication: Registration
	r.Post("/api/v1/auth/register", handlers.RegisterUser)

	// User Authentication: Login
	// This route allows users to log in and receive a JWT token
	r.Post("/api/v1/auth/login", handlers.LoginUser)

	// User Authentication: Logout
	// This route allows users to log out by invalidating their JWT token
	r.Post("/api/v1/auth/logout", handlers.LogoutUser)

	// Routes that require authentication
	// This group of routes will require the user to be authenticated
	r.Group(func(r chi.Router) {
		r.Use(handlers.AuthMiddleware) // Apply the authentication middleware to all routes in this group

		// Article Submission endpoint
		// This route allows authenticated users to submit articles
		r.Post("/api/v1/articles", handlers.SubmitArticle)

		// Article Management Endpoints
		// These routes allow users to manage their articles, including viewing, updating, and deleting
		r.Get("/api/v1/articles/{id}", handlers.ReturnArticle)              // Return article by ID
		r.Get("/api/v1/articles", handlers.GetArticlesByUserID)             // Get all articles for a user
		r.Get("/api/v1/articles/tags", handlers.GetTagsByUserID)            // Get all tags for a user
		r.Put("/api/v1/articles/{id}/status", handlers.UpdateArticleStatus) // Update an existing article status
		r.Put("/api/v1/articles/{id}/tags", handlers.UpdateArticleTags)     // Update an existing article tags
		r.Delete("/api/v1/articles/{id}", handlers.DeleteArticle)           // Delete an article by ID
		r.Get("/api/v1/tags", handlers.GetTagsByUserID)                     // Get all tags across all articles
	})

	// Serve Swagger UI
	// The URL for Swagger UI will be http://localhost:8080/swagger/index.html
	r.Get("/swagger/*", httpSwagger.Handler(
		httpSwagger.URL("/swagger/doc.json"), // This is the default path generated by swag
		httpSwagger.DeepLinking(true),
		httpSwagger.DocExpansion("none"), // Collapsed by default
		httpSwagger.DomID("swagger-ui"),
	))
	// Graceful Shutdown Setup
	server := &http.Server{Addr: ":8080", Handler: r}

	// Channel to listen for OS signals (e.g., Ctrl+C)
	stop := make(chan os.Signal, 1)
	signal.Notify(stop, os.Interrupt, syscall.SIGTERM) // Listen for Ctrl+C and kill signal

	// Start server in a goroutine so it doesn't block
	go func() {
		fmt.Println("Server starting on :8080")
		fmt.Println("Access API docs at http://localhost:8080/swagger/index.html")
		if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("Could not listen on %s: %v\n", server.Addr, err)
		}
	}()

	// Block until a signal is received
	<-stop

	// Shutdown the server gracefully
	log.Println("Shutting down server...")
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second) // 5 second timeout for graceful shutdown
	defer cancel()

	if err := server.Shutdown(ctx); err != nil {
		log.Fatalf("Server forced to shutdown: %v", err)
	}

	log.Println("Server exited gracefully.")

}

// @Summary Show API health status
// @Description Checks if the API is up and running.
// @ID health-check
// @Produce json
// @Success 200 {string} string "OK"
// @Router  / [get]
func healthCheckHandler(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	fmt.Fprintf(w, "API is running")
}
